<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Five-Section Survey</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    :root {
      --bg: #0f1412;
      --card: rgba(255, 255, 255, 0.08);
      --card-strong: rgba(255, 255, 255, 0.12);
      --ink: #f5f6f5;
      --muted: #cfd6cf;
      --accent: #a59172;   /* palette */
      --accent-2: #273e33; /* palette */
      --accent-3: #d8ceaf; /* palette */
      --danger: #ff6b6b;
      --ok: #4cd964;
      --radius: 18px;
      --shadow: 0 10px 30px rgba(0, 0, 0, 0.25);
      --radio-size: 14px;          /* radio size */
      --option-font-size: 13px;    /* label size */

      /* Selected highlight tokens (tweak these to taste) */
      --selected-bg: rgba(165, 145, 114, 0.14);    /* soft accent wash */
      --selected-bd: rgba(216, 206, 175, 0.85);    /* light border */
      --selected-glow: 0 0 0 6px rgba(165, 145, 114, 0.18); /* outer glow */
    }

    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      color: var(--ink);
      background:
        radial-gradient(1200px 800px at 20% -10%, #1f2c27 0%, transparent 60%),
        radial-gradient(1200px 800px at 120% 0%, #1f2c27 0%, transparent 50%),
        linear-gradient(180deg, #15201b 0%, var(--bg) 100%);
      font: 16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
    }

    header.appbar {
      position: sticky; top: 0; z-index: 50;
      backdrop-filter: blur(12px);
      background: linear-gradient(180deg, rgba(21, 32, 27, 0.9), rgba(21, 32, 27, 0.6));
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
    }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 16px 20px; }
    .brand { display: flex; align-items: center; gap: 12px; }
    .logo {
      width: 32px; height: 32px; border-radius: 10px;
      background: conic-gradient(from 180deg, var(--accent-3), var(--accent), var(--accent-2), var(--accent-3));
      box-shadow: inset 0 0 0 2px rgba(255, 255, 255, 0.15);
    }
    .title { font-weight: 700; letter-spacing: 0.2px; }

    nav.sections { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 12px; }
    nav.sections a {
      text-decoration: none; color: var(--ink);
      background: var(--card); padding: 8px 12px; border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      transition: transform .15s ease, background .2s ease;
    }
    nav.sections a:hover { transform: translateY(-1px); background: var(--card-strong); }

    .progress {
      margin-top: 14px; background: rgba(255,255,255,0.08);
      height: 10px; border-radius: 999px; overflow: hidden;
      border: 1px solid rgba(255,255,255,0.08);
    }
    .bar {
      height: 100%; width: 0%;
      background: linear-gradient(90deg, var(--accent-2), var(--accent), var(--accent-3));
      transition: width .25s ease;
    }
    .meter { margin-top: 6px; font-size: 17px; color: var(--muted); }

    main { padding: 24px 20px 100px; }
    .grid {
      max-width: 1100px; margin: 0 auto; display: grid; gap: 20px;
      grid-template-columns: 1fr;
    }
    @media (min-width: 900px) { .grid { grid-template-columns: 1fr 1fr; } }

    /* Plain options */
    .choices .choice {
      background: transparent !important;
      border: 0 !important;
      border-radius: 0 !important;
      padding: 0 !important;
      box-shadow: none !important;
      transform: none !important;
      flex-direction: column;       /* radio on top, text below */
      align-items: center;
      text-align: center;
      gap: 6px;
      transition: transform .12s ease, box-shadow .2s ease, background .2s ease, border-color .2s ease;
    }
    .choices .choice:hover { background: transparent !important; }
    .choices { gap: 10px 18px; }

    /* Option label */
    .choices .choice .tag {
      background: transparent !important;
      border: 0 !important;
      border-radius: 0 !important;
      padding: 0 !important;
      color: var(--ink);
      font-weight: 500;
      display: block; line-height: 1.1;
      font-size: var(--option-font-size);
      transition: color .2s ease;
    }

    /* Radio size + color (no scaling) */
    .choices .choice input[type="radio"] {
      margin: 0;
      width: var(--radio-size); height: var(--radio-size);
      min-width: var(--radio-size); min-height: var(--radio-size);
      accent-color: var(--accent);
    }
    .choices .choice input[type="radio"]:focus-visible + .tag {
      outline: none;
      box-shadow: inset 0 -2px 0 0 rgba(165,145,114,.8);
    }

    /* Selected state — CSS-only if :has is supported */
    @supports selector(:has(*)) {
      .choices .choice:has(input[type="radio"]:checked) {
        background: var(--selected-bg) !important;
        border: 1px solid var(--selected-bd) !important;
        border-radius: 10px !important;
        padding: 8px 10px !important;
        box-shadow: var(--selected-glow) !important;
        transform: translateY(-1px) !important;
      }
      .choices .choice:has(input[type="radio"]:checked) .tag {
        color: #ffffff;
        font-weight: 600;
      }
    }
    /* Fallback if :has is not supported — JS toggles .is-selected */
    .choices .choice.is-selected {
      background: var(--selected-bg) !important;
      border: 1px solid var(--selected-bd) !important;
      border-radius: 10px !important;
      padding: 8px 10px !important;
      box-shadow: var(--selected-glow) !important;
      transform: translateY(-1px) !important;
    }
    .card .body fieldset{
        display: grid;
        gap: 10px;
        }
    .choices .choice.is-selected .tag { color: #ffffff; font-weight: 600; }

    section.card {
      background: var(--card);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: clip;
    }
    .card header {
      padding: 16px 18px;
      background: linear-gradient(180deg, rgba(168,145,114,0.12), rgba(168,145,114,0.02));
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    .card h2 { margin: 0; font-size: 18px; letter-spacing: 0.3px; }
    .card .body { padding: 16px 18px 18px; display: grid; gap: 14px; }

    fieldset {
      border: 1px dashed rgba(255,255,255,0.18);
      border-radius: 14px; padding: 14px;
      display: grid; gap: 2px; /* gap between questions */
    }
    legend { padding: 0 8px; color: var(--muted); font-size: 15px; }

    .question {
      display: grid; gap: 10px;
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px; padding: 12px;
    }
    .q-title { font-weight: 600; }
    .choices {
      display: grid; gap: 8px;
      grid-template-columns: repeat(2, minmax(0,1fr));
    }
    @media (min-width: 640px) { .choices { grid-template-columns: repeat(4, minmax(0,1fr)); } }

    .error { border-color: rgba(255,0,0,0.45) !important; box-shadow: 0 0 0 3px rgba(255,0,0,0.15) inset; }
    .error-msg { color: var(--danger); font-size: 13px; display: none; }
    .question.invalid .error-msg { display: block; }

    /* Comment question */
    .question.comment { gap: 8px; }
    .question.comment textarea {
      width: 100%; min-height: 90px; resize: vertical;
      color: var(--ink);
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.16);
      border-radius: 10px;
      padding: 10px 12px; font: inherit;
    }
    .question.comment textarea:focus {
      outline: none; border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(165,145,114,.30);
    }
    .comment .char-counter { font-size: 12px; color: var(--muted); justify-self: end; }

    /* Attachment UI */
    .attachment {
      display: grid; gap: 8px;
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 10px; padding: 10px;
    }
    .attachment .label-row {
      display: flex; align-items: baseline; gap: 10px; flex-wrap: wrap;
      color: var(--muted); font-size: 13px;
    }
    .attachment .label-row .hint { opacity: .9; }
    .attachment .file-row {
      display: flex; align-items: center; gap: 10px; flex-wrap: wrap;
    }
    .attachment input[type="file"] {
      color: var(--ink);
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.16);
      border-radius: 8px; padding: 6px 8px;
      font: inherit;
    }
    .attachment button.remove {
      appearance: none; border: 1px solid rgba(255,255,255,0.25);
      background: transparent; color: var(--ink);
      padding: 6px 10px; border-radius: 8px; cursor: pointer;
    }
    .attachment button.remove:hover { filter: brightness(1.1); }
    .file-info { font-size: 12px; color: var(--muted); }
    .file-error { font-size: 12px; color: var(--danger); }

    .actions {
      position: sticky; bottom: 0; z-index: 40;
      background: linear-gradient(180deg, rgba(21,32,27,0), rgba(21,32,27,0.95) 35%);
      padding: 22px 20px 30px; border-top: 1px solid rgba(255,255,255,0.08);
    }
    .actions .wrap-inner {
      max-width: 1100px; margin: 0 auto; display: flex; gap: 12px; flex-wrap: wrap;
    }
    button.btn {
      appearance: none; border: none; cursor: pointer;
      padding: 12px 18px; border-radius: 12px; font-weight: 700;
      color: #121412; background: var(--accent-3);
      box-shadow: var(--shadow); transition: transform .12s ease, filter .2s ease;
    }
    button.btn:hover { transform: translateY(-1px); filter: brightness(1.05); }
    button.ghost { background: transparent; color: var(--ink); border: 1px solid rgba(255,255,255,0.2); }

    .toast {
      position: fixed; right: 16px; bottom: 16px; z-index: 60;
      background: rgba(0,0,0,0.78); padding: 12px 14px; border-radius: 12px; font-size: 14px;
      border: 1px solid rgba(255,255,255,0.12); display: none;
    }
    .toast.show { display: block; animation: pop .18s ease; }
    @keyframes pop { from { transform: scale(.98); opacity: 0; } to { transform: scale(1); opacity: 1; } }

    .sr-only {
      position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden;
      clip: rect(0,0,0,0); white-space: nowrap; border: 0;
    }
  </style>
</head>
<body>

  <header class="appbar">
    <div class="wrap">
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <div class="title">Security Keys • Five-Section Survey</div>
      </div>

      <nav class="sections" id="sectionNav" aria-label="Section navigation"></nav>

      <div class="progress" aria-hidden="true">
        <div class="bar" id="progressBar"></div>
      </div>
      <div class="meter" id="progressText">Answered 0 of 25</div>
    </div>
  </header>

  <main>
    <form id="surveyForm" class="grid" autocomplete="off" novalidate></form>
  </main>

  <div class="actions">
    <div class="wrap-inner">
      <button type="button" class="btn ghost" id="btnReset">Reset</button>
      <button type="submit" class="btn" id="btnSubmit" form="surveyForm">Submit</button>
      <span id="a11yStatus" class="sr-only" aria-live="polite"></span>
    </div>
  </div>

  <div class="toast" id="toast" role="status" aria-live="polite"></div>

  <script>
  (() => {
    'use strict';

    // ----- Survey data (edit text here) -----
    const sections = [
      {
        id: 'sec1',
        title: 'Access Control',
        questions: [
          'Our team follows a consistent process for requesting keys.',
          'Key collection points are clearly identified and accessible.',
          'Temporary access is logged accurately.',
          'Visitors are never given permanent keys.',
          'Lost keys are reported immediately.'
        ]
      },
      {
        id: 'sec2',
        title: 'Policies & Procedures',
        questions: [
          'Key handover rules are clearly communicated.',
          'Return deadlines are reasonable and understood.',
          'Exceptions require approval from a supervisor.',
          'Audits are performed at regular intervals.',
          'Policy changes are shared promptly.'
        ]
      },
      {
        id: 'sec3',
        title: 'Equipment & Tools',
        questions: [
          'Key tags and labels are readable.',
          'Storage cabinets are secure and organized.',
          'Scanning devices (barcode/RFID) work reliably.',
          'Spare keys are tracked correctly.',
          'Damaged keys are removed from circulation.'
        ]
      },
      {
        id: 'sec4',
        title: 'Incident Response',
        questions: [
          'There is a clear escalation path for late keys.',
          'We can identify who holds a key at any time.',
          'Overdue reminders are sent automatically.',
          'Incidents are reviewed after resolution.',
          'Lessons learned are documented.'
        ]
      },
      {
        id: 'sec5',
        title: 'Training & Awareness',
        questions: [
          'New staff receive key-handling training.',
          'Refresher sessions happen as needed.',
          'Guides are easy to find and follow.',
          'Roles and responsibilities are understood.',
          'Feedback is collected and acted upon.'
        ]
      }
    ];

    const choices = [
      { label: 'Strongly Disagree', value: '1' },
      { label: 'Disagree',          value: '2' },
      { label: 'Agree',             value: '3' },
      { label: 'Strongly Agree',    value: '4' }
    ];

    // ----- DOM refs -----
    const form = document.getElementById('surveyForm');
    const nav  = document.getElementById('sectionNav');
    const progressBar  = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    const toast = document.getElementById('toast');
    const a11yStatus = document.getElementById('a11yStatus');
    const btnReset = document.getElementById('btnReset');

    // ----- Helpers -----
    function el(tag, cls, text){
      const e = document.createElement(tag);
      if (cls) e.className = cls;
      if (typeof text === 'string') e.textContent = text;
      return e;
    }

    // Fallback highlight toggler (for browsers without :has)
    function updateSelectedClasses(scope=document){
      const labels = scope.querySelectorAll('label.choice');
      labels.forEach(l => {
        const input = l.querySelector('input[type="radio"]');
        if (!input) return;
        if (input.checked) l.classList.add('is-selected');
        else l.classList.remove('is-selected');
      });
    }

    // Attachment validation helpers
    const MAX_BYTES = 10 * 1024 * 1024; // 10 MB
    const PDF_MIME = 'application/pdf';

    function toMB(bytes){ return (bytes / (1024*1024)).toFixed(2); }

    function getElById(id){ return document.getElementById(id); }

    function validateNameAndType(file){
      const nameOk = /\.pdf$/i.test(file.name || '');
      const typeOk = (file.type === PDF_MIME);
      return nameOk && typeOk;
    }

    function readFirstBytes(file, n = 5){
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = () => resolve(new Uint8Array(reader.result || new ArrayBuffer(0)));
        reader.onerror = () => resolve(new Uint8Array());
        reader.readAsArrayBuffer(file.slice(0, n));
      });
    }

    async function isPdfMagic(file){
      const bytes = await readFirstBytes(file, 5);
      const sig = Array.from(bytes).map(b => String.fromCharCode(b)).join('');
      return sig === '%PDF-';
    }

    async function validateAttachmentInput(input, infoEl, errEl){
      errEl.textContent = '';
      infoEl.textContent = '';

      const files = input.files;
      if (!files || files.length === 0) return true; // optional

      if (files.length > 1){
        errEl.textContent = 'Only one file is allowed.';
        input.value = '';
        return false;
      }

      const f = files[0];

      if (f.size > MAX_BYTES){
        errEl.textContent = `File too large (${toMB(f.size)} MB). Max allowed is 10 MB.`;
        input.value = '';
        return false;
      }

      if (!validateNameAndType(f)){
        errEl.textContent = 'PDF only (.pdf, application/pdf).';
        input.value = '';
        return false;
      }

      const magicOk = await isPdfMagic(f);
      if (!magicOk){
        errEl.textContent = 'File signature is not a valid PDF.';
        input.value = '';
        return false;
      }

      infoEl.textContent = `${f.name} (${toMB(f.size)} MB)`;
      return true;
    }

    async function validateAllAttachments(){
      const inputs = form.querySelectorAll('input[type="file"][data-role="pdf-attachment"]');
      let allOk = true;
      for (const input of inputs){
        const infoEl = getElById(input.dataset.infoId);
        const errEl  = getElById(input.dataset.errId);
        const ok = await validateAttachmentInput(input, infoEl, errEl);
        if (!ok) allOk = false;
      }
      return allOk;
    }

    function buildSurvey(){
      // Build nav
      sections.forEach((s, i) => {
        const a = document.createElement('a');
        a.href = `#${s.id}`;
        a.textContent = `${i+1}. ${s.title}`;
        a.addEventListener('click', (ev) => {
          ev.preventDefault();
          const target = document.getElementById(s.id);
          if (target) target.scrollIntoView({behavior: 'smooth', block: 'start'});
        });
        nav.appendChild(a);
      });

      // Build sections/cards
      sections.forEach((s, si) => {
        const card = el('section', 'card');
        card.id = s.id;

        const head = el('header', null);
        const h2 = el('h2', null, `${si+1}. ${s.title}`);
        head.appendChild(h2);

        const body = el('div', 'body');

        // One fieldset per section groups its questions
        const fs = document.createElement('fieldset');
        const lg = document.createElement('legend');
        lg.textContent = 'Please choose one option per question';
        fs.appendChild(lg);

        // 5 radio questions
        s.questions.forEach((q, qi) => {
          const qid = `q-${si+1}-${qi+1}`;

          const qWrap = el('div', 'question');
          qWrap.setAttribute('role', 'group');
          qWrap.setAttribute('aria-labelledby', `${qid}-label`);

          const qTitle = el('div', 'q-title');
          qTitle.id = `${qid}-label`;
          qTitle.textContent = `${si+1}.${qi+1} — ${q}`;

          const choicesWrap = el('div', 'choices');

          choices.forEach((c, ci) => {
            const label = el('label', 'choice');
            const input = document.createElement('input');
            input.type = 'radio';
            input.name = qid;
            input.value = c.value;
            if (ci === 0) input.required = true; // group required via first radio

            const tag = el('span', 'tag', c.label);
            label.appendChild(input);
            label.appendChild(tag);
            choicesWrap.appendChild(label);
          });

          const msg = el('div', 'error-msg', 'Please select one option.');
          qWrap.appendChild(qTitle);
          qWrap.appendChild(choicesWrap);
          qWrap.appendChild(msg);
          fs.appendChild(qWrap);
        });

        // 6th item — optional comment + attachment
        const commentWrap = el('div', 'question comment');
        const cTitle = el('div', 'q-title', `${si+1}.6 — Additional comments (optional)`);
        const textarea = document.createElement('textarea');
        textarea.name = `q-${si+1}-6-comment`;
        textarea.maxLength = 500;
        textarea.placeholder = "Type your note (max 500 characters)";
        textarea.setAttribute('aria-label', `Comments for ${s.title}`);
        const counter = el('div', 'char-counter', `0 / ${textarea.maxLength}`);
        textarea.addEventListener('input', () => {
          counter.textContent = `${textarea.value.length} / ${textarea.maxLength}`;
        });

        // Attachment block
        const attId = `att-${si+1}-6`;
        const infoId = `att-info-${si+1}-6`;
        const errId  = `att-err-${si+1}-6`;

        const attWrap = el('div', 'attachment');
        const labelRow = el('div', 'label-row');
        const attLbl = el('label', null, 'Attach PDF (optional)');
        attLbl.setAttribute('for', attId);
        const hint = el('span', 'hint', 'PDF only • Max 10 MB • One file');
        labelRow.appendChild(attLbl);
        labelRow.appendChild(hint);

        const fileRow = el('div', 'file-row');
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.id = attId;
        fileInput.name = attId;
        fileInput.accept = 'application/pdf,.pdf';
        fileInput.multiple = false;
        fileInput.setAttribute('data-role','pdf-attachment');
        fileInput.setAttribute('data-info-id', infoId);
        fileInput.setAttribute('data-err-id', errId);

        const removeBtn = el('button', 'remove', 'Remove');
        removeBtn.type = 'button';
        removeBtn.addEventListener('click', () => {
          fileInput.value = '';
          getElById(infoId).textContent = '';
          getElById(errId).textContent = '';
        });

        const fileInfo = el('div', 'file-info'); fileInfo.id = infoId;
        const fileErr  = el('div', 'file-error'); fileErr.id = errId;

        fileInput.addEventListener('change', async () => {
          await validateAttachmentInput(fileInput, fileInfo, fileErr);
        });

        fileRow.appendChild(fileInput);
        fileRow.appendChild(removeBtn);

        attWrap.appendChild(labelRow);
        attWrap.appendChild(fileRow);
        attWrap.appendChild(fileInfo);
        attWrap.appendChild(fileErr);

        commentWrap.appendChild(cTitle);
        commentWrap.appendChild(textarea);
        commentWrap.appendChild(counter);
        commentWrap.appendChild(attWrap);

        fs.appendChild(commentWrap);

        body.appendChild(fs);
        card.appendChild(head);
        card.appendChild(body);
        form.appendChild(card);
      });

      // initialize fallback selection class
      updateSelectedClasses(form);
    }

    // ----- Progress tracking -----
    function updateProgress(){
      const total = sections.reduce((acc, s) => acc + s.questions.length, 0);
      const answered = form.querySelectorAll('input[type="radio"]:checked').length;
      const pct = Math.round((answered / total) * 100);
      progressBar.style.width = pct + '%';
      progressText.textContent = `Answered ${answered} of ${total}`;
      a11yStatus.textContent = `Progress: ${answered} of ${total} answered`;
    }

    // ----- Validation (radio groups) -----
    function validateAllRadios(){
      let firstInvalid = null;
      form.querySelectorAll('.question').forEach(q => {
        q.classList.remove('invalid', 'error');
      });

      const groups = new Set();
      form.querySelectorAll('input[type="radio"]').forEach(r => groups.add(r.name));

      let invalidCount = 0;
      groups.forEach(name => {
        const group = Array.from(form.querySelectorAll(`input[name="${CSS.escape(name)}"]`));
        const checked = group.some(r => r.checked);
        if (!checked){
          invalidCount++;
          const wrap = group[0].closest('.question');
          if (wrap){
            wrap.classList.add('invalid', 'error');
            if (!firstInvalid) firstInvalid = wrap;
          }
        }
      });

      if (firstInvalid){
        firstInvalid.scrollIntoView({behavior: 'smooth', block: 'center'});
        const r = firstInvalid.querySelector('input[type="radio"]');
        if (r) r.focus({preventScroll:true});
      }
      return invalidCount === 0;
    }

    // ----- Toast -----
    function showToast(msg, ms=2200){
      toast.textContent = msg;
      toast.classList.add('show');
      window.setTimeout(() => toast.classList.remove('show'), ms);
    }

    // ----- Event wiring -----
    function wire(){
      // update progress + selection highlight on change
      form.addEventListener('change', (e) => {
        if (e.target && e.target.matches('input[type="radio"]')){
          const wrap = e.target.closest('.question');
          if (wrap){ wrap.classList.remove('invalid', 'error'); }
          updateSelectedClasses(wrap); // fallback selection class
          updateProgress();
        }
      });

      // handle submit
      form.addEventListener('submit', async (e) => {
        e.preventDefault();

        const radiosOk = validateAllRadios();
        const attsOk = await validateAllAttachments();

        if (!radiosOk || !attsOk){
          showToast('Please complete required answers and fix attachment errors.');
          return;
        }

        // Collect answers safely
        const data = {};
        const checked = form.querySelectorAll('input[type="radio"]:checked');
        checked.forEach(r => { data[r.name] = r.value; });

        // include non-empty comments
        form.querySelectorAll('textarea[name$="-comment"]').forEach(t => {
          const v = t.value.trim();
          if (v) data[t.name] = v;
        });

        // gather valid attachments (optional)
        const attPayload = [];
        const attInputs = form.querySelectorAll('input[type="file"][data-role="pdf-attachment"]');
        for (const input of attInputs){
          const files = input.files;
          if (files && files.length === 1){
            attPayload.push({ name: input.name, file: files[0] });
          }
        }

        // Example: send to server (placeholder)
        // IMPORTANT server-side measures:
        //  - Verify MIME & extension AND sniff content (magic bytes).
        //  - AV scan (e.g., ClamAV) + PDF sanitization (qpdf/ocr layer if needed).
        //  - Store in quarantine path; never serve directly from upload path.
        //  - Use short-lived pre-signed URLs for any download; Content-Disposition: attachment.
        //  - Enforce size limits server-side; strip metadata if policy requires.
        //  - CSRF protection, authZ, rate limiting.
        //
        // const formData = new FormData();
        // formData.append('answers', JSON.stringify(data));
        // attPayload.forEach((a, i) => formData.append(`attachment_${i}`, a.file, a.file.name));
        // await fetch('/submit', {
        //   method: 'POST',
        //   headers: { 'X-CSRF-Token': token }, // supply from server/template
        //   body: formData,
        //   credentials: 'include',
        // });

        showToast('All good! Answers and attachments validated locally (demo).');
        console.log('Collected answers (demo):', data);
        console.log('Attachments (demo):', attPayload.map(a => ({ name: a.file.name, size: a.file.size })));
      });

      // reset button
      btnReset.addEventListener('click', () => {
        form.reset();
        updateProgress();
        form.querySelectorAll('.question').forEach(q => q.classList.remove('invalid','error'));
        updateSelectedClasses(form);
        form.querySelectorAll('.file-info').forEach(e => e.textContent = '');
        form.querySelectorAll('.file-error').forEach(e => e.textContent = '');
        showToast('Form reset.');
      });

      // Warn on unload if partially filled
      window.addEventListener('beforeunload', (e) => {
        const answered = form.querySelectorAll('input[type="radio"]:checked').length;
        const anyFiles = form.querySelectorAll('input[type="file"][data-role="pdf-attachment"]').length > 0;
        if (answered > 0 || anyFiles){
          e.preventDefault();
          e.returnValue = '';
        }
      });
    }

    // ----- Init -----
    buildSurvey();
    wire();
    updateProgress();

    // Security notes (client-side)
    // - No untrusted HTML injection; all dynamic text uses textContent.
    // - Radio names are fixed & index-based (no user-controlled IDs).
    // - Client validates type/size/signature; SERVER MUST re-validate & scan.
    // - Set strict HTTP headers (CSP, HSTS, X-Content-Type-Options, etc.).
  })();
  </script>
</body>
</html>
